
**************************************------------------------------------------<br></P><p><p></p>
TYPE CASTING= (PRIMITIVE CASTING = EXPLICIT+ IMPLICIT )+ (DERIVED TYPE CASTING= UPACATING+ DOWNCASTING )
POLYMORPHIC BEHAVAIOR
ECLIPSE PROJECT
**************************************------------------------------------------<br></P><p><p></p>
TYPE CASTING- conversion of one type data to another type- 
PRIMITIVE TYPE CASTING - EXPLICIT(with force decrease 100) & IMPLICIT ( without froce data increase 100.18) 
EXPLICIT(with force) where data is lost double d =108.12 beacome int x= d , noe here will be x= 100
IMPLICIT ( without froce) where data is adding x= 108 become double =108.11 like integar change to double, 
DERIVED TYPE CASTING- HANDLOCK 
UPACATING- subcalass promted to super class object- only super class it will show only super class content call upcastting
superclass variable= new subclass/PARENT ( superclass class = c1, c2)- converted to super class, HIDDEN SUB/CHILD CLASS CLASS object
 Subclass/child extend super/main class ( to inherit super class)
DOWNCASTING : when we access all subclass and superclass methods (superclass= c1, c2 and subclass= c3, c4)
subclass ref= new subclass ();

under public static main void {}
OR UPCAST DOWNCAST
or upcast
superclass obj2 = (superclass obj;
obj2.c1();
obj2.c2();
and downcast 
subclass ref = (subclass) obj2;
ref.c1();
ref.c2();
ref.c3();
ref.c4();
POLYMORPHIC BEHAVAIOR= when object behave muliple way like upcasting and method overrriding together
ECLIPSE PROJECT
**************************************------------------------------------------<br></P><p><p></p>

PRIMITIVE TYPE CASTING - 
EXPLICIT(with force) where data is lost double d =108.12 beacome int x= d , noe here will be x= 100
IMPLICIT ( without froce) where data is adding x= 108 become double =108.11
like integar change to double, 
**************************************------------------------------------------<br></P><p><p></p>
byte- <short-int-log-float-double
memory is expanding
double-float-long-int-short-byte
(memory is shrinking)

package TypeCasting;

public class TypeConversion {

public static void main (String [] args)

int x = 20;

double d = x;
System. out.println ("d = " + d);

char ch = 'a';

int i = ch;
System. out.println("i =" + i);

// double type to integer
double dd = 100.68;
int y = (int) dd;
System. out.println("Y = " + y) ;

**************************************------------------------------------------<br></P><p><p></p>
DERIVED TYPE CASTING - EXPLICIT(with force) & IMPLICIT 
( without froce)handlock situation get created where all sub class content will not be visbile

**************************************------------------------------------------<br></P><p><p></p>
UPCASTING: object of sub class and have all subclass and super class content
SubClass obj = new SubClass () ;
obj.cl (); I
obj.c2();
obj.c3();
obj.c4();
DOWNCASTING: its super class object --- have only super class content not subclass object 
SubClass obj = new SubClass () ;
obj.cl (); I
obj.c2();

**************************************
SUPER CLASS
**************************************
package TypeCasting;

public class SuperCiass

public void c1() {
System. out.println ("Running in cl() of SuperClass");

public void c2() {
System. out.println("Running in c2() of SuperClass");

public static void main (String [] args) {

SuperClass ref = new SuperClass () ;
ref.cl();
ref.c2();

}}}
**************************************
SUB CLASS- it has all super and sub class object
**************************************
public class SubClass extends SuperClass{

public void c3() {
System. out.println ("Running in c3() of SubClass");

public void c4() {
System. out.println ("Running in c4() of SubClass");

}

public static void main (String[] args) {

//Sub Class object
SubClass obj = new SubClass () ;
obj.cl ();
obj.c2();
obj.c3();
obj.c4();

//conversion of sub class super class object (UPCASTING)
SuperClass obj2 = [SuperClass) obj;
System. out.println (":
obj2.cl();
obj2.c2();

=== UPCASTING=SUPER CLASS IS DECLARE TYPE========= ");
SubClass ref = (SubClass) obj2;
System. out.println ("== DOWN CASTING======== ") ;

ref.cl();
ref.c2();
ref.c3();
ref.c4();


}

}

**************************************------------------------------------------<br></P><p><p></p>
PLOYMORPHISM-when object shows different behavior 
>> Upcasting with overwriting ---- one object shows different behaivior/excecution time/late binding, dynamic/
 run time as object get created during executuion or run time
<br>
>>>method overloading when method can exist multiple time, with arguments

**************************************------------------------------------------<br></P><p><p></p>
Super class
**************************************------------------------------------------<br></P><p><p></p>
package TypeCasting;

public class A {
public void cl() {
System. out.println ("Running in cl() of A");

ebruary25thCorelava/src/lypeCasting/Bjava

public void c2() {
System. out.println ("Running in c2() of A");



**************************************------------------------------------------<br></P><p><p></p>
Subclass
**************************************------------------------------------------<br></P><p><p></p>
package TypeCasting;

public class B extends A{
public void cl () {
System. out.println ("Running in cl() of B");

public void c4() {
System. out.println ("Running in c4() of B");

public static void main (String[] args) {

//Sub class object
B b = new B() ;
//b.cl ();

//sub class to super class object
//Up casting
A a= (A) b;

a.cl(); // here upcasting is their but also method overloading is there and will show the 
subclass content rather than superclass even though same method exist in super class and sub class will over required
a.c2();

}

**************************************------------------------------------------<br></P><p><p></p>
SELENIUM 
**************************************------------------------------------------<br></P><p><p></p>
>>Search context(interface) that have two method - find elements(); findElelmet();
method implimentation is not there
>> WebDriver(interface) extends is used between interface and interface  with class will be extends
it will extend property of search context
get(string url), close();, refresh(); 
>> Remotewebdriver(class)- fully implimented class
it will implimmetns and impliment word will be used to impliment all the method of webdriver abd search context
>> Browser classes, chrome driver, firefox, safari, edge


**************************************------------------------------------------<br></P><p><p></p>
CREATE NEW PROJECT IN ECLIPSE
**************************************------------------------------------------<br></P><p><p></p>
File> New> Other> Maven> Maven project> next> Next> maven- accetype-quickstart- 1.1> click>
 group id= big project name, artifact id> name of the project> package will be automatically created
 it will get create and src will be there under source, main and test will have java in for code- code will be there
 Pom.xml>> <Depnedencies>we will have jar file here </Depnedencies>
 >> go to maven repository>>https://mvnrepository.com/
  java selenium https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java and come and paste in Depnedencies, 
  its basically a selnium project
 >> go to project, check build automatically and save
 >> create a driver folder in eclipse
 check in google chrome setting, at bottom about>> see  what is your version, download google chrome drive ,
  unzip and paste in the driver folder, change in this url the version you want
https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.77/win64/chromedriver-win64.zip
141.0.7390.77 

https://github.com/GoogleChromeLabs/chrome-for-testing#json-api-endpoints
can look more here
>> maven covert code to application , called build management tool, it add also dependecies etc
